# React Native Mobile App Development Prompts
## NFC Medical Profile Platform (MedGuard) - Step-by-Step Guide

**Instructions**: Copy each prompt below and give it to Claude Code ONE BY ONE. Wait for each prompt to be completed before moving to the next one.

---

## PROMPT 1: Project Initialization

```
Create a new React Native Expo project for the MedGuard mobile app with the following requirements:

1. Initialize the project:
   - Use Expo with TypeScript template
   - Project name: "MedGuardMobile"
   - Setup in a new directory: ../MedGuardMobile

2. Install all required dependencies:
   - Navigation: @react-navigation/native, @react-navigation/stack, @react-navigation/bottom-tabs
   - API: axios, @tanstack/react-query
   - State: zustand
   - Forms: react-hook-form
   - Storage: @react-native-async-storage/async-storage
   - NFC: react-native-nfc-manager
   - Icons: @expo/vector-icons
   - UI: react-native-paper
   - QR: expo-camera, expo-barcode-scanner
   - Auth: expo-local-authentication
   - Other: date-fns, zod

3. Configure TypeScript:
   - Strict mode enabled
   - Path aliases: @/* pointing to src/*
   - Proper tsconfig.json setup

4. Create initial folder structure:
   ```
   src/
   â”œâ”€â”€ api/              # API client and endpoints
   â”œâ”€â”€ components/       # Reusable UI components
   â”‚   â”œâ”€â”€ ui/          # Basic UI components (Button, Input, Card, etc.)
   â”‚   â””â”€â”€ shared/      # Shared app components
   â”œâ”€â”€ screens/         # All app screens
   â”‚   â”œâ”€â”€ auth/       # Login, Signup, etc.
   â”‚   â”œâ”€â”€ dashboard/  # Dashboard screens
   â”‚   â””â”€â”€ emergency/  # Emergency profile view
   â”œâ”€â”€ navigation/      # Navigation configuration
   â”œâ”€â”€ store/          # Zustand state management
   â”œâ”€â”€ hooks/          # Custom React hooks
   â”œâ”€â”€ utils/          # Utility functions
   â”œâ”€â”€ types/          # TypeScript types
   â”œâ”€â”€ constants/      # Constants (colors, API endpoints, etc.)
   â””â”€â”€ theme/          # Theme configuration
   ```

5. Setup .env file with:
   ```
   API_BASE_URL=http://localhost:3000
   API_TIMEOUT=30000
   ```

6. Create app.json with proper configuration for NFC, camera, and biometric permissions

Complete this setup and confirm when ready for the next step.
```

---

## PROMPT 2: Theme & Design System Setup

```
Create the complete theme and design system matching the web app's design:

1. Create src/constants/colors.ts with the EXACT colors from the web app:
   - Primary red color scheme: #dc2626 (primary-600), #ef4444 (primary-500), etc.
   - Full primary color scale (50-950)
   - Medical colors: red (#ef4444), blue (#3b82f6), yellow (#f59e0b)
   - Gray scale for UI elements
   - Status colors: success, warning, error, info

2. Create src/theme/theme.ts with:
   - Typography scale (matching Inter font from web)
   - Spacing scale (4, 8, 12, 16, 24, 32, 48, 64)
   - Border radius values
   - Shadow configurations
   - Animation durations

3. Create src/constants/styles.ts with:
   - Common styles for containers
   - Card styles
   - Shadow styles matching web app
   - Responsive breakpoints

4. Setup React Native Paper theme in src/theme/paperTheme.ts:
   - Configure with primary red color
   - Match web app's button styles
   - Input field styling
   - Card styling

Use the exact design tokens from the web app (tailwind.config.ts and globals.css).
```

---

## PROMPT 3: API Client & Authentication Setup

```
Create the API client and authentication system that connects to the existing Next.js backend:

1. Create src/api/client.ts:
   - Axios instance with base URL from .env
   - Request interceptor to add JWT token from AsyncStorage
   - Response interceptor for error handling
   - Token refresh logic
   - Timeout configuration

2. Create src/api/auth.ts with all auth endpoints:
   - login(email, password)
   - signup(userData)
   - logout()
   - verifyEmail(code)
   - enable2FA()
   - verify2FA(code)
   - getMe()
   - forgotPassword(email)
   - resetPassword(token, newPassword)

3. Create src/store/authStore.ts using Zustand:
   - State: user, token, isAuthenticated, isLoading
   - Actions: setUser, setToken, logout, checkAuth
   - Persist token to AsyncStorage
   - Load token on app start

4. Create src/hooks/useAuth.ts:
   - Custom hook to access auth store
   - Login handler
   - Logout handler
   - Check authentication status

5. Create src/types/auth.ts:
   - User interface matching backend
   - LoginRequest, SignupRequest types
   - SessionData type

Ensure all API calls match the existing Next.js API routes format.
```

---

## PROMPT 4: UI Components Library (Part 1)

```
Create the base UI components matching the web app's design:

1. src/components/ui/Button.tsx:
   - Variants: primary, secondary, outline, ghost, danger
   - Sizes: sm, md, lg
   - Loading state with spinner
   - Icon support
   - Disabled state
   - Ripple effect on press
   - Exact styling matching web Button component
   - Shadow effects for primary/danger variants

2. src/components/ui/Input.tsx:
   - Label, placeholder, error message
   - Secure text entry option (password)
   - Icon support (left/right)
   - Error state with red border
   - Focus state styling
   - Helper text
   - Full accessibility support

3. src/components/ui/Card.tsx:
   - Padding variants
   - Shadow styling matching web
   - Border radius
   - Background color
   - Pressable option
   - Elevation support

4. src/components/ui/Badge.tsx:
   - Color variants: success, warning, error, info, default
   - Sizes: sm, md, lg
   - Icon support
   - Exact styling from web Badge component

Use React Native's StyleSheet and match the exact visual appearance of web components.
```

---

## PROMPT 5: UI Components Library (Part 2)

```
Create additional UI components:

1. src/components/ui/Modal.tsx:
   - Full-screen and center variants
   - Close button
   - Animation on open/close
   - Backdrop with blur
   - Header, body, footer sections
   - Swipe to dismiss (optional)

2. src/components/ui/Select.tsx:
   - Dropdown selection
   - Label and error support
   - Search functionality
   - Multiple selection option
   - Custom option rendering

3. src/components/ui/TextArea.tsx:
   - Multi-line input
   - Character count
   - Max length
   - Auto-grow option
   - Error state styling

4. src/components/ui/LoadingSpinner.tsx:
   - Full-screen loading overlay
   - Inline spinner
   - Color variants
   - Size variants

5. src/components/ui/Toast.tsx:
   - Success, error, warning, info variants
   - Auto-dismiss
   - Position: top/bottom
   - Swipe to dismiss
   - Icon support

Match the exact styling from the web app's UI components.
```

---

## PROMPT 6: Navigation Setup

```
Create the complete navigation structure:

1. src/navigation/types.ts:
   - Define all screen params
   - AuthStackParamList
   - AppStackParamList
   - DashboardTabParamList

2. src/navigation/AuthNavigator.tsx:
   - Stack navigator for auth screens
   - Screens: Login, Signup, ForgotPassword, VerifyEmail, 2FAVerify
   - Header styling matching theme
   - Transition animations

3. src/navigation/DashboardNavigator.tsx:
   - Bottom tab navigator
   - Tabs: Home, Profile, Bracelet, Settings
   - Custom tab bar styling with red active color
   - Icons from @expo/vector-icons (Ionicons)
   - Badge support for notifications

4. src/navigation/AppNavigator.tsx:
   - Stack navigator for main app
   - Screens: Dashboard (nested tabs), AuditLogs, Subscription, EmergencyView
   - Modal screens configuration

5. src/navigation/RootNavigator.tsx:
   - Conditional rendering based on auth state
   - Shows AuthNavigator or AppNavigator
   - Loading screen while checking auth
   - Deep linking configuration

Setup navigation with proper TypeScript types and match web app's routing structure.
```

---

## PROMPT 7: Authentication Screens

```
Create all authentication screens matching the web app:

1. src/screens/auth/LoginScreen.tsx:
   - Email and password inputs
   - "Remember me" checkbox
   - Login button with loading state
   - "Forgot password?" link
   - "Sign up" navigation link
   - Form validation with react-hook-form
   - Error handling with Toast
   - Biometric login option (Face ID/Touch ID)
   - Match exact layout from web login page

2. src/screens/auth/SignupScreen.tsx:
   - Full name, username, email, password, confirm password
   - Terms and conditions checkbox
   - Signup button with loading
   - "Already have account?" link
   - Password strength indicator
   - Form validation
   - Navigate to VerifyEmail after signup

3. src/screens/auth/ForgotPasswordScreen.tsx:
   - Email input
   - "Send reset link" button
   - Success message
   - Back to login link

4. src/screens/auth/VerifyEmailScreen.tsx:
   - 6-digit code input
   - Verify button
   - Resend code button with timer
   - Auto-focus inputs
   - Navigate to dashboard after verification

Use the same styling, spacing, and animations as the web app.
```

---

## PROMPT 8: Dashboard Home Screen

```
Create the main dashboard home screen:

1. src/screens/dashboard/HomeScreen.tsx:
   - Header with user greeting and profile picture
   - Stats cards (4 cards in 2x2 grid):
     * Profile completeness
     * Bracelet status
     * Recent accesses
     * Active subscription
   - Health reminders section:
     * List of health reminders
     * Priority indicators (high/medium/low)
     * Complete button for each reminder
     * Empty state when no reminders
   - Recent activity section:
     * Last 5 activities
     * Action, timestamp, location
     * "View all" button to AuditLogs
   - Quick actions buttons:
     * View Emergency Profile
     * Scan NFC Bracelet
     * Update Profile

2. Create src/api/dashboard.ts:
   - getDashboardStats()
   - getHealthReminders()
   - getRecentActivities()
   - completeReminder(id)

3. Use React Query for data fetching with loading/error states

4. Pull-to-refresh functionality

5. Match the exact design from web dashboard page (app/dashboard/page.tsx)

Include proper TypeScript types and error handling.
```

---

## PROMPT 9: Medical Profile Screen

```
Create the medical profile editor screen:

1. src/screens/dashboard/ProfileScreen.tsx:
   - Sectioned form with the following sections:

     **Basic Information:**
     - Blood type (dropdown)
     - Height and weight inputs
     - Date of birth picker
     - Gender selection

     **Medical Conditions:**
     - List of conditions with add/remove
     - Add condition button
     - Each condition deletable

     **Allergies:**
     - List with allergen, severity, reaction
     - Add allergy button with modal
     - Severity dropdown (mild/moderate/severe)
     - Each allergy deletable

     **Medications:**
     - List of current medications
     - Each showing: name, dosage, frequency
     - Add medication button
     - Navigate to separate add medication screen

     **Emergency Notes:**
     - Multi-line text area
     - Character count (max 500)

     **Medical Directives:**
     - Organ donor toggle switch
     - DNR status toggle switch

2. Create src/api/profile.ts:
   - getProfile()
   - updateProfile(data)
   - addAllergy(data)
   - removeAllergy(id)
   - addMedication(data)
   - removeMedication(id)

3. Use react-hook-form for form management

4. Save button at bottom with loading state

5. Success Toast on save

6. Match exact styling from web profile page (app/dashboard/profile/page.tsx)
```

---

## PROMPT 10: Emergency Contacts & Doctor Info

```
Create emergency contacts and doctor information screens:

1. src/screens/dashboard/EmergencyContactsScreen.tsx:
   - List of emergency contacts
   - Each card showing:
     * Name
     * Relationship
     * Phone number (with call button)
     * Email
     * Edit/Delete buttons
   - Add contact FAB (Floating Action Button)
   - Empty state with illustration
   - Swipe to delete gesture

2. src/screens/dashboard/AddEditContactScreen.tsx:
   - Modal or full-screen form
   - Fields: name, relationship, phone, email
   - Save button
   - Validation

3. src/screens/dashboard/DoctorInfoScreen.tsx:
   - Doctor details form:
     * Doctor name
     * Phone number (with call button)
     * Email
     * Specialty
     * Address
   - Save button
   - If no doctor info, show empty state

4. Create src/api/contacts.ts:
   - getEmergencyContacts()
   - addEmergencyContact(data)
   - updateEmergencyContact(id, data)
   - deleteEmergencyContact(id)
   - getDoctorInfo()
   - updateDoctorInfo(data)

5. One-tap phone calling functionality using Linking.openURL

Match web app's emergency contacts design.
```

---

## PROMPT 11: NFC Bracelet Management Screen

```
Create the NFC bracelet management screen with full functionality:

1. src/screens/dashboard/BraceletScreen.tsx:
   - If bracelet is linked:
     * Bracelet status card (active/inactive/lost)
     * NFC ID display
     * Linked date
     * Last accessed timestamp
     * Total access count
     * QR code display section
     * "Download QR" button
     * "Unlink Bracelet" button
     * "Test Emergency Profile" button

   - If no bracelet:
     * Empty state with illustration
     * "Link NFC Bracelet" button
     * "Scan with NFC" button (primary)
     * "Enter manually" option
     * Instructions on how to link

2. src/screens/dashboard/NFCScanScreen.tsx:
   - Full-screen NFC scanning UI
   - Animated scanning indicator
   - Instructions text
   - Cancel button
   - Handle NFC read events
   - Auto-link after successful scan
   - Error handling

3. src/screens/dashboard/QRCodeScreen.tsx:
   - Full-screen QR code display
   - Emergency profile URL encoded
   - Download as image option
   - Share functionality
   - Print option

4. Create src/api/bracelet.ts:
   - getBraceletStatus()
   - linkBracelet(nfcId, deviceInfo)
   - unlinkBracelet()
   - generateQRCode()

5. Create src/services/nfcService.ts:
   - Initialize NFC manager
   - startNFCScanning()
   - stopNFCScanning()
   - writeToNFC(data)
   - readFromNFC()
   - Check NFC availability

6. Match exact design from web bracelet page (app/dashboard/bracelet/page.tsx)

Include proper NFC permissions handling and error messages.
```

---

## PROMPT 12: Emergency Profile View Screen

```
Create the emergency profile viewer (for responders):

1. src/screens/emergency/EmergencyProfileScreen.tsx:
   - Public screen (no auth required)
   - Accept bracelet ID as parameter
   - Display sections:

     **Header:**
     - Emergency alert banner (red)
     - "EMERGENCY MEDICAL INFORMATION" title
     - Patient name and age

     **Critical Information Cards:**
     - Blood type (large, prominent)
     - Allergies (red cards with severity)
     - Current medications (blue cards)
     - Medical conditions (yellow cards)

     **Emergency Contacts:**
     - List with name, relationship
     - Large "CALL" buttons (green)
     - One-tap calling functionality

     **Additional Information:**
     - DNR status (if yes, prominent display)
     - Organ donor status
     - Height and weight
     - Emergency notes

     **Doctor Information:**
     - Doctor name and specialty
     - Contact information
     - Call button

     **Footer:**
     - Last updated timestamp
     - Access counter
     - Privacy notice

2. Create src/api/emergency.ts:
   - getEmergencyProfile(braceletId)
   - This calls /api/emergency/[braceletId] on backend

3. Large, readable text for emergency responders

4. High contrast colors for critical information

5. Loading state while fetching profile

6. Error handling (bracelet not found, inactive, etc.)

7. Match exact design from web emergency page (app/emergency/[braceletId]/page.tsx)

This screen should be optimized for quick reading in emergency situations.
```

---

## PROMPT 13: Audit Logs & Activity Screen

```
Create the audit logs/activity tracking screen:

1. src/screens/dashboard/AuditLogsScreen.tsx:
   - Header with title and filter button
   - Filter options:
     * Date range picker
     * Activity type filter (access/update/system/security)
     * Reset filters button

   - Activity list:
     * Each item showing:
       - Activity icon based on type
       - Action description
       - Timestamp (relative time)
       - Location (city, country)
       - Device information
       - IP address (expandable)
     * Expandable cards for full details
     * Infinite scroll / pagination
     * Pull to refresh

   - Empty state when no activities

   - Export button (generate PDF/CSV)

2. Create src/api/activities.ts:
   - getActivities(filters, page, limit)
   - getActivityDetails(id)
   - exportActivities(format)

3. Create src/components/ActivityCard.tsx:
   - Reusable activity item component
   - Different styling per activity type
   - Expandable for metadata

4. Filter modal:
   - Date range selector
   - Activity type checkboxes
   - Apply/Cancel buttons

5. Match exact design from web audit logs page (app/dashboard/audit-logs/page.tsx)

Include proper loading states and pagination indicators.
```

---

## PROMPT 14: Settings & Account Management

```
Create the settings screen with all account management options:

1. src/screens/dashboard/SettingsScreen.tsx:
   - Grouped settings list:

     **Account Section:**
     - Profile picture (with edit option)
     - Full name (tap to edit)
     - Email (tap to edit, requires verification)
     - Username (tap to edit)
     - Phone number (tap to edit)

     **Security Section:**
     - Change password (navigate to screen)
     - Two-factor authentication toggle
     - Biometric login toggle
     - Active sessions list

     **Notifications Section:**
     - Profile access alerts toggle
     - Health reminders toggle
     - Subscription updates toggle
     - Security alerts toggle
     - Marketing emails toggle

     **Privacy Section:**
     - Download my data button
     - Delete account button (with confirmation)
     - Privacy policy link
     - Terms of service link

     **App Section:**
     - App version
     - Check for updates
     - Clear cache button
     - Logout button (red)

2. Create separate screens:
   - src/screens/settings/ChangePasswordScreen.tsx
   - src/screens/settings/EditProfileScreen.tsx
   - src/screens/settings/SecuritySettingsScreen.tsx
   - src/screens/settings/NotificationSettingsScreen.tsx

3. Create src/api/settings.ts:
   - updateProfile(data)
   - changePassword(oldPassword, newPassword)
   - updateNotificationSettings(settings)
   - enable2FA()
   - disable2FA()
   - exportData()
   - deleteAccount()

4. Confirmation modals for destructive actions

5. Toast notifications for successful updates

6. Match web settings page design (app/dashboard/settings/page.tsx)
```

---

## PROMPT 15: Subscription Management Screen

```
Create the subscription management screen:

1. src/screens/dashboard/SubscriptionScreen.tsx:
   - Current subscription card:
     * Plan name (Free/Monthly/Yearly)
     * Status badge (active/cancelled/expired)
     * Current period dates
     * Next billing date
     * Amount charged
     * Cancel at period end notice (if applicable)

   - Plan comparison cards:
     * Free plan features
     * Monthly plan ($9.99 CAD)
     * Yearly plan ($99.99 CAD)
     * Feature checkmarks
     * "Current plan" or "Upgrade" buttons

   - Billing history section:
     * List of past invoices
     * Date, amount, status
     * Download invoice button
     * View invoice button

   - Payment method section:
     * Card details (last 4 digits)
     * Expiry date
     * "Update payment method" button

   - Action buttons:
     * Upgrade/Downgrade plan
     * Cancel subscription (with confirmation)
     * Resume subscription (if cancelled)
     * Update payment method

2. Create src/api/subscription.ts:
   - getSubscription()
   - createCheckoutSession(planId)
   - upgradePlan(newPlanId)
   - cancelSubscription()
   - resumeSubscription()
   - getInvoices()
   - downloadInvoice(invoiceId)

3. Open Stripe checkout in WebView or browser

4. Success/cancel callbacks from Stripe

5. Confirmation modals for subscription changes

6. Match web subscription page (app/dashboard/subscription/page.tsx)

Note: Stripe integration requires proper setup in app.json for deep linking.
```

---

## PROMPT 16: Shared Components & Utilities

```
Create shared components and utility functions:

1. src/components/shared/Header.tsx:
   - Reusable header component
   - Title, back button, action buttons
   - Used across all screens

2. src/components/shared/EmptyState.tsx:
   - Illustration/icon
   - Title and description
   - Action button (optional)
   - Used for empty lists

3. src/components/shared/ErrorState.tsx:
   - Error icon
   - Error message
   - Retry button
   - Used for API errors

4. src/components/shared/ConfirmDialog.tsx:
   - Modal confirmation dialog
   - Title, message
   - Confirm/Cancel buttons
   - Used for destructive actions

5. src/utils/validation.ts:
   - Email validation
   - Password strength check
   - Phone number validation
   - NFC ID format validation
   - Zod schemas for forms

6. src/utils/formatting.ts:
   - formatDate(date)
   - formatDateTime(date)
   - formatRelativeTime(date)
   - formatBloodType(type)
   - formatPhoneNumber(phone)

7. src/utils/storage.ts:
   - saveToken(token)
   - getToken()
   - removeToken()
   - saveBiometricPreference(enabled)
   - getBiometricPreference()

8. src/hooks/useDebounce.ts:
   - Debounce hook for search inputs

9. src/hooks/useBiometric.ts:
   - Check biometric availability
   - Authenticate with biometric
   - Save biometric preference

10. src/constants/config.ts:
    - API endpoints
    - App version
    - Feature flags
    - Timeouts

Match utility functions from web app's lib/utils.ts
```

---

## PROMPT 17: NFC Service Implementation

```
Implement the complete NFC service:

1. src/services/nfcService.ts:
   - Class-based NFC service with singleton pattern

   Methods:
   - init(): Initialize NFC manager
   - isSupported(): Check if device supports NFC
   - isEnabled(): Check if NFC is enabled
   - startScanning(onRead, onError): Start NFC scanning
   - stopScanning(): Stop NFC scanning
   - writeTag(nfcId, profileUrl): Write data to NFC tag
   - readTag(): Read data from NFC tag
   - formatTag(): Format NFC tag (clear data)

2. NFC data format:
   - Store emergency profile URL
   - Store NFC ID
   - Store user ID (encrypted)
   - NDEF message format

3. Error handling:
   - NFC not supported
   - NFC disabled (guide user to settings)
   - Tag read/write errors
   - Timeout errors

4. Background NFC (Android only):
   - Setup deep linking for NFC tags
   - Handle app launch from NFC tag
   - Navigate to emergency profile

5. iOS limitations handling:
   - Read-only support
   - User must initiate scan
   - Clear instructions for users

6. Create src/screens/dashboard/NFCWriteScreen.tsx:
   - Screen to write emergency URL to NFC tag
   - Step-by-step instructions
   - Animated "hold phone to tag" UI
   - Success/error feedback

Test thoroughly on physical devices (iOS and Android).
```

---

## PROMPT 18: Biometric Authentication

```
Implement biometric authentication:

1. src/services/biometricService.ts:
   - Check biometric availability
   - Get biometric type (Face ID, Touch ID, Fingerprint)
   - Authenticate user
   - Handle errors and fallback

2. Create src/screens/auth/BiometricSetupScreen.tsx:
   - Shown after first login
   - Explain biometric benefits
   - Enable/Skip buttons
   - Show biometric type icon

3. Integrate biometric in LoginScreen:
   - Show biometric button if enabled
   - Auto-trigger on app open (optional)
   - Fallback to password if biometric fails
   - Re-enable option after disabling

4. Security considerations:
   - Store token encrypted in Keychain/Keystore
   - Never store password for biometric
   - Require password after multiple failures
   - Option to disable in Settings

5. Platform-specific UI:
   - iOS: Face ID or Touch ID
   - Android: Fingerprint or Face unlock

6. Error handling:
   - Biometric not enrolled
   - Biometric hardware not available
   - Too many attempts
   - User cancellation

Test on devices with different biometric types.
```

---

## PROMPT 19: Offline Mode & Data Sync

```
Implement offline functionality and data synchronization:

1. src/services/offlineService.ts:
   - Detect online/offline status
   - Queue API requests when offline
   - Sync queued requests when online
   - Handle conflicts

2. src/store/offlineStore.ts (Zustand):
   - State: isOnline, queuedRequests, lastSync
   - Actions: addToQueue, syncQueue, clearQueue
   - Persist queue to AsyncStorage

3. Local caching strategy:
   - Cache user profile
   - Cache medical profile
   - Cache emergency contacts
   - Cache bracelet status
   - Cache recent activities
   - TTL (Time To Live) for each cache

4. Create src/db/cache.ts:
   - saveToCache(key, data, ttl)
   - getFromCache(key)
   - clearCache(key)
   - clearAllCache()
   - isExpired(key)

5. Optimistic updates:
   - Update UI immediately
   - Queue request for later
   - Show "Pending sync" indicator
   - Rollback on failure

6. Offline indicator:
   - Banner at top when offline
   - Show cached data timestamp
   - Disable actions that require internet

7. Emergency profile offline access:
   - Cache emergency profile locally
   - Works without internet
   - Critical for emergencies!

8. Sync conflict resolution:
   - Detect conflicts (local vs server)
   - Merge strategy
   - User choice for conflicts

9. Pull-to-refresh syncs all data

Test thoroughly by toggling airplane mode.
```

---

## PROMPT 20: Push Notifications

```
Implement push notifications system:

1. Setup Expo Notifications:
   - Configure app.json for notifications
   - Request notification permissions
   - Get push token
   - Send token to backend

2. src/services/notificationService.ts:
   - Register for push notifications
   - Handle notification received (foreground)
   - Handle notification tapped (background/killed)
   - Schedule local notifications
   - Cancel notifications
   - Get notification settings

3. Notification types:
   - Emergency profile accessed
   - Health reminder due
   - Subscription expiring
   - Security alert
   - New feature announcement

4. Create src/api/notifications.ts:
   - registerPushToken(token, deviceInfo)
   - updateNotificationSettings(settings)
   - getNotifications()
   - markAsRead(notificationId)

5. In-app notification center:
   - src/screens/dashboard/NotificationsScreen.tsx
   - List of all notifications
   - Badge count on tab bar
   - Mark as read/unread
   - Delete notifications
   - Clear all

6. Deep linking from notifications:
   - Navigate to specific screens
   - Handle when app is closed
   - Handle when app is in background

7. Local notifications for health reminders:
   - Schedule based on user preferences
   - Daily reminder at specific time
   - Medication reminders

8. Notification settings in Settings screen:
   - Enable/disable by type
   - Quiet hours
   - Sound preferences

Test on physical devices (push notifications don't work in simulator).
```

---

## PROMPT 21: QR Code Scanner

```
Implement QR code scanning functionality:

1. src/screens/dashboard/QRScannerScreen.tsx:
   - Full-screen camera view
   - QR code scanning using expo-camera
   - Scanning frame overlay
   - Instructions text
   - Flashlight toggle button
   - Cancel button

2. Features:
   - Scan QR code on bracelet
   - Automatically detect emergency profile URL
   - Parse NFC ID from URL
   - Navigate to emergency profile
   - Vibration feedback on successful scan

3. Permissions handling:
   - Request camera permission
   - Show permission denied screen
   - Guide user to settings

4. Alternative to NFC:
   - Use when NFC not available
   - Use when NFC is disabled
   - Works on all devices

5. Generate QR code in BraceletScreen:
   - Use expo-qrcode or react-native-qrcode-svg
   - Display emergency profile URL
   - Save QR code to gallery
   - Share QR code

6. Error handling:
   - Invalid QR code
   - Not a MedGuard QR code
   - Network error fetching profile

7. Quick action from dashboard:
   - "Scan QR Code" button
   - Opens scanner immediately

Test with actual QR codes generated from web app.
```

---

## PROMPT 22: Error Handling & Loading States

```
Implement comprehensive error handling and loading states:

1. Create src/components/shared/LoadingOverlay.tsx:
   - Full-screen loading spinner
   - Semi-transparent backdrop
   - Loading message
   - Used during critical operations

2. Create src/hooks/useApiQuery.ts:
   - Wrapper around React Query
   - Automatic error handling
   - Toast on error
   - Retry logic
   - Loading states

3. Create src/hooks/useApiMutation.ts:
   - Wrapper for mutations
   - Optimistic updates
   - Error rollback
   - Success toast
   - Loading button state

4. Error boundary:
   - src/components/ErrorBoundary.tsx
   - Catch React errors
   - Show friendly error screen
   - Report to Sentry (optional)
   - Restart button

5. API error handling:
   - Network errors (no internet)
   - Timeout errors
   - 401 Unauthorized (logout)
   - 403 Forbidden
   - 404 Not Found
   - 500 Server Error
   - Show appropriate messages

6. Form validation errors:
   - Show inline errors
   - Highlight invalid fields
   - Scroll to first error
   - Clear error on change

7. Loading skeletons:
   - Create src/components/ui/Skeleton.tsx
   - Use instead of spinners
   - Match content layout
   - Animated shimmer effect

8. Empty states:
   - Friendly illustrations
   - Helpful messages
   - Call-to-action buttons

9. Offline state handling:
   - Show cached data
   - Indicate data is stale
   - Queue actions
   - Show sync status

10. Global error toast:
    - Appears at top of screen
    - Auto-dismiss after 5s
    - Swipe to dismiss
    - Different colors per type

Ensure every screen has proper loading and error states.
```

---

## PROMPT 23: Animations & Interactions

```
Add animations and interactions for professional feel:

1. Install react-native-reanimated and react-native-gesture-handler

2. Screen transitions:
   - Slide animation for stack navigation
   - Fade animation for modals
   - Scale animation for dialogs
   - Custom transitions

3. List animations:
   - FlatList with animated items
   - Staggered entrance animation
   - Swipe-to-delete animation
   - Pull-to-refresh animation

4. Button interactions:
   - Scale down on press
   - Ripple effect (Android)
   - Haptic feedback
   - Loading animation

5. Card interactions:
   - Hover effect (slight elevation)
   - Press animation
   - Expandable cards
   - Swipe gestures

6. Input animations:
   - Label animation (floating label)
   - Shake animation on error
   - Success checkmark animation

7. Loading animations:
   - Skeleton shimmer
   - Progress indicators
   - Spinner animations
   - Pulse effects

8. NFC scanning animation:
   - Radar scanning effect
   - Pulsing circle
   - Success checkmark
   - Error shake

9. Tab bar animation:
   - Active tab scale
   - Icon bounce on press
   - Badge pulse

10. Create src/utils/animations.ts:
    - Reusable animation configs
    - Timing functions
    - Spring configurations

11. Haptic feedback:
    - Use expo-haptics
    - Success haptic
    - Error haptic
    - Selection haptic
    - Impact feedback

12. Micro-interactions:
    - Checkbox animation
    - Toggle switch animation
    - Radio button animation
    - Progress bar animation

Keep animations smooth (60 FPS) and purposeful, not distracting.
Match the smooth feel of the web app's Framer Motion animations.
```

---

## PROMPT 24: Performance Optimization

```
Optimize app performance:

1. Image optimization:
   - Use expo-image for better performance
   - Lazy load images
   - Proper image sizing
   - Cache images
   - Placeholder while loading

2. List optimization:
   - Use FlatList with proper keyExtractor
   - Implement getItemLayout for better performance
   - Use windowSize prop
   - Memo list items
   - Remove clipping on Android

3. React optimization:
   - Use React.memo for expensive components
   - Use useMemo for expensive calculations
   - Use useCallback for functions passed to children
   - Avoid inline functions in render
   - Proper key props

4. Bundle size optimization:
   - Remove unused dependencies
   - Use tree-shaking
   - Split large screens into chunks
   - Lazy load screens

5. API optimization:
   - Implement pagination
   - Debounce search inputs
   - Cache API responses
   - Prefetch data
   - Parallel requests where possible

6. State management optimization:
   - Only subscribe to needed state
   - Avoid unnecessary re-renders
   - Use selectors
   - Split stores by domain

7. Navigation optimization:
   - Lazy load screens
   - Unmount inactive screens
   - Optimize transitions

8. Startup time optimization:
   - Splash screen while loading
   - Lazy initialize services
   - Defer non-critical tasks
   - Measure startup time

9. Memory management:
   - Clean up listeners
   - Cancel pending requests
   - Clear caches periodically
   - Proper cleanup in useEffect

10. Monitoring:
    - Use Flipper for debugging
    - Monitor memory usage
    - Profile performance
    - Check frame rate

11. Create src/utils/performance.ts:
    - Performance measurement utilities
    - Log slow operations
    - Alert if frame drops

Test on low-end devices to ensure good performance.
```

---

## PROMPT 25: Testing & Quality Assurance

```
Setup testing infrastructure:

1. Install testing libraries:
   - @testing-library/react-native
   - jest
   - @testing-library/jest-native

2. Unit tests:
   - Test utility functions (src/utils/__tests__)
   - Test API client (src/api/__tests__)
   - Test validation functions
   - Test formatters

3. Component tests:
   - Test UI components (src/components/__tests__)
   - Test Button with all variants
   - Test Input with validation
   - Test forms
   - Snapshot tests

4. Integration tests:
   - Test authentication flow
   - Test API calls with mocked responses
   - Test navigation
   - Test data persistence

5. E2E tests (optional):
   - Use Detox
   - Test critical user flows
   - Login flow
   - Profile update flow
   - NFC scanning flow

6. Create test utilities:
   - src/test/setup.ts
   - Mock API responses
   - Mock navigation
   - Mock AsyncStorage
   - Test wrappers

7. API testing:
   - Test all API endpoints
   - Test error handling
   - Test token refresh
   - Test offline queue

8. Accessibility testing:
   - Test screen reader support
   - Test keyboard navigation
   - Test touch target sizes
   - Test color contrast

9. Manual testing checklist:
   - Create TESTING_CHECKLIST.md
   - List all features to test
   - Test on iOS and Android
   - Test on different screen sizes
   - Test offline mode
   - Test NFC on physical device

10. Code quality:
    - Setup ESLint
    - Setup Prettier
    - Add pre-commit hooks
    - Type checking with TypeScript

Aim for 80%+ code coverage on critical paths.
```

---

## PROMPT 26: Security Hardening

```
Implement security best practices:

1. Secure storage:
   - Use expo-secure-store for sensitive data
   - Encrypt tokens before storage
   - Never store passwords
   - Clear sensitive data on logout

2. API security:
   - Certificate pinning
   - Timeout configurations
   - Request signing
   - Rate limiting on client

3. Network security:
   - Use HTTPS only
   - Validate SSL certificates
   - No cleartext traffic (Android)
   - Detect proxy/VPN (optional)

4. Authentication security:
   - Biometric fallback to password
   - Auto-logout after inactivity
   - Detect jailbreak/root
   - Session timeout

5. Code obfuscation:
   - Setup ProGuard (Android)
   - Use Hermes for code obfuscation
   - Remove console.logs in production

6. Prevent tampering:
   - Detect modified app
   - Verify app signature
   - Anti-debugging measures (optional)

7. Data validation:
   - Validate all user inputs
   - Sanitize data
   - Use Zod schemas
   - Server-side validation

8. Permissions:
   - Request only needed permissions
   - Explain why permissions needed
   - Handle permission denial gracefully

9. Sensitive data display:
   - Hide sensitive data in app switcher
   - Blur screen on background (iOS)
   - Prevent screenshots (optional, controversial)

10. Create src/utils/security.ts:
    - Security utility functions
    - Detect rooted device
    - Check app integrity
    - Validate SSL pins

11. Environment variables:
    - Never commit .env
    - Different configs for dev/prod
    - Secure API keys

12. Error messages:
    - Don't expose sensitive info in errors
    - Generic error messages for security issues

Medical data requires highest security standards!
```

---

## PROMPT 27: Deployment Preparation

```
Prepare app for deployment to App Store and Google Play:

1. App Icons:
   - Create app icons for all sizes
   - iOS: 1024x1024 (required)
   - Android: Adaptive icon
   - Use expo-icon generator
   - Professional medical-themed icon

2. Splash Screen:
   - Create splash screen
   - Match brand colors (red theme)
   - MedGuard logo
   - Loading indicator

3. App Configuration (app.json):
   - Proper app name: "MedGuard"
   - Bundle identifiers
   - Version numbers (1.0.0)
   - Build numbers
   - Permissions with descriptions
   - Deep linking scheme
   - Orientation settings
   - Status bar styling

4. iOS specific:
   - Privacy descriptions for Info.plist
   - Camera: "Access camera to scan QR codes"
   - NFC: "Access NFC to scan medical bracelets"
   - Biometric: "Use Face ID for secure login"
   - Notifications: "Receive alerts when profile accessed"

5. Android specific:
   - Permissions in AndroidManifest.xml
   - NFC intent filters
   - Deep linking intent filters
   - Adaptive icon

6. Build configuration:
   - Development build
   - Staging build
   - Production build
   - Different API endpoints per environment

7. Store listings:
   - Create STORE_LISTING.md with:
     * App title
     * Short description
     * Full description
     * Keywords
     * Screenshots (required sizes)
     * Feature graphics
     * Privacy policy URL
     * Support URL
     * Marketing URL

8. Privacy Policy:
   - Create or link privacy policy
   - Explain data collection
   - PIPEDA compliance
   - Medical data handling

9. Screenshots:
   - Generate screenshots for all devices
   - iPhone 6.7", 6.5", 5.5"
   - iPad Pro 12.9", 11"
   - Android: Various sizes
   - Show key features

10. Beta testing:
    - TestFlight (iOS)
    - Google Play Beta
    - Invite testers
    - Collect feedback

11. Build commands:
    ```bash
    # Development
    eas build --profile development --platform ios
    eas build --profile development --platform android

    # Production
    eas build --profile production --platform ios
    eas build --profile production --platform android
    ```

12. Submission checklist:
    - All features tested
    - No crashes
    - Passes App Store guidelines
    - Passes Google Play guidelines
    - Age rating determined
    - Content rating (IARC)
    - Export compliance

Ready all assets before submission.
```

---

## PROMPT 28: Documentation & Developer Guide

```
Create comprehensive documentation:

1. README.md for mobile app:
   - Project overview
   - Features list
   - Tech stack
   - Prerequisites
   - Installation instructions
   - Environment setup
   - Running the app
   - Building for production
   - Troubleshooting

2. ARCHITECTURE.md:
   - App architecture diagram
   - Folder structure explained
   - State management approach
   - Navigation flow
   - API integration
   - Offline strategy
   - NFC implementation

3. DEVELOPMENT.md:
   - Development setup
   - Code style guide
   - Component creation guide
   - Adding new screens
   - API integration guide
   - Testing guide
   - Common issues

4. API_DOCUMENTATION.md:
   - All API endpoints
   - Request/response formats
   - Authentication flow
   - Error codes
   - Rate limits

5. DEPLOYMENT.md:
   - Build process
   - Environment configuration
   - Release process
   - App Store submission
   - Google Play submission
   - Version management

6. USER_GUIDE.md:
   - How to use the app
   - Feature explanations
   - Troubleshooting for users
   - FAQ

7. Inline code comments:
   - Document complex logic
   - Explain non-obvious code
   - TODO comments for future work
   - FIXME for known issues

8. Type documentation:
   - JSDoc comments for types
   - Interface descriptions
   - Enum explanations

9. Changelog:
   - CHANGELOG.md
   - Version history
   - New features
   - Bug fixes
   - Breaking changes

10. Contributing guide:
    - CONTRIBUTING.md
    - Code of conduct
    - Pull request process
    - Coding standards

Keep documentation updated with code changes.
```

---

## PROMPT 29: Final Polish & UX Enhancements

```
Add final polish and UX improvements:

1. Onboarding flow:
   - Create src/screens/onboarding/
   - 3-4 intro slides explaining app
   - Benefits of NFC bracelet
   - How to link bracelet
   - Privacy and security info
   - Skip button
   - Get started button

2. Empty states:
   - Design beautiful empty states for all lists
   - Friendly illustrations
   - Helpful call-to-action
   - Match web app's empty states

3. Success animations:
   - Lottie animations for success states
   - Checkmark animation
   - Profile saved animation
   - Bracelet linked animation

4. Loading states:
   - Skeleton screens for all loading states
   - Smooth transitions
   - Progress indicators

5. Accessibility:
   - Screen reader support (VoiceOver/TalkBack)
   - Proper accessibility labels
   - Semantic HTML elements
   - Keyboard navigation
   - High contrast mode support
   - Font scaling support

6. Internationalization (i18n):
   - Setup expo-localization
   - English strings
   - Ready for translation
   - Date/time localization
   - Number formatting

7. Dark mode (optional):
   - Dark theme colors
   - Toggle in settings
   - System preference detection
   - Smooth theme switching

8. Help & Support:
   - In-app help center
   - FAQ screen
   - Contact support button
   - Video tutorials (optional)
   - Chat support (optional)

9. Feedback mechanism:
   - Rate app prompt
   - Feedback form
   - Bug report button
   - Feature request option

10. App updates:
    - Check for updates on launch
    - Show update dialog
    - Force update for critical versions
    - What's new screen after update

11. Analytics (optional):
    - Setup analytics tracking
    - Track screen views
    - Track user actions
    - Track errors
    - Privacy-conscious tracking

12. Performance monitoring:
    - Setup Sentry or similar
    - Track crashes
    - Track performance issues
    - User session replay

13. Final touches:
    - Review all animations
    - Check all transitions
    - Verify all error messages
    - Test all edge cases
    - Proofread all copy
    - Consistent spacing
    - Consistent colors
    - Consistent fonts

Test entire app flow from start to finish multiple times.
```

---

## PROMPT 30: Final Testing & Launch Checklist

```
Complete final testing and prepare for launch:

1. Functional testing:
   - [ ] All screens load correctly
   - [ ] All buttons work
   - [ ] All forms submit
   - [ ] All validations work
   - [ ] Navigation works everywhere
   - [ ] Back button works correctly
   - [ ] Deep links work
   - [ ] Push notifications work
   - [ ] NFC scanning works (on device)
   - [ ] QR scanning works
   - [ ] Biometric auth works
   - [ ] Offline mode works
   - [ ] Data syncs correctly
   - [ ] API calls succeed
   - [ ] Error handling works
   - [ ] Loading states show
   - [ ] Empty states show

2. Platform testing:
   - [ ] iOS: iPhone (all supported versions)
   - [ ] iOS: iPad (tablet layout)
   - [ ] Android: Various screen sizes
   - [ ] Android: Different OS versions
   - [ ] Different network conditions
   - [ ] Offline functionality
   - [ ] Slow network

3. Edge cases:
   - [ ] No internet connection
   - [ ] Server down
   - [ ] Invalid tokens
   - [ ] Expired sessions
   - [ ] Corrupted data
   - [ ] Full storage
   - [ ] No permissions
   - [ ] Denied permissions

4. Security testing:
   - [ ] Tokens stored securely
   - [ ] Password not stored
   - [ ] HTTPS enforced
   - [ ] Certificate validation
   - [ ] Biometric fallback works
   - [ ] Auto-logout works
   - [ ] Sensitive data hidden

5. Performance testing:
   - [ ] App starts quickly
   - [ ] Smooth animations (60 FPS)
   - [ ] No memory leaks
   - [ ] Lists scroll smoothly
   - [ ] Images load fast
   - [ ] API calls are quick
   - [ ] Battery usage acceptable

6. Compliance:
   - [ ] Privacy policy linked
   - [ ] Terms of service linked
   - [ ] PIPEDA compliant
   - [ ] Age rating appropriate
   - [ ] Content rating acquired
   - [ ] Export compliance done

7. Store assets:
   - [ ] App icon created
   - [ ] Screenshots captured (all sizes)
   - [ ] Feature graphic created
   - [ ] Promotional images ready
   - [ ] Video preview (optional)
   - [ ] Store listing written
   - [ ] Keywords optimized

8. Build verification:
   - [ ] Development build works
   - [ ] Staging build works
   - [ ] Production build works
   - [ ] Version numbers correct
   - [ ] Bundle IDs correct
   - [ ] Certificates valid
   - [ ] Provisioning profiles valid

9. Beta testing:
   - [ ] TestFlight build submitted
   - [ ] Beta testers invited
   - [ ] Feedback collected
   - [ ] Critical bugs fixed
   - [ ] Google Play beta live
   - [ ] Beta testers invited
   - [ ] Feedback collected

10. Launch preparation:
    - [ ] Marketing materials ready
    - [ ] Social media posts prepared
    - [ ] Press release drafted
    - [ ] Support team trained
    - [ ] Backend ready for load
    - [ ] Monitoring setup
    - [ ] Rollback plan ready

11. Submission:
    - [ ] iOS: Submit to App Store Connect
    - [ ] iOS: Submit for review
    - [ ] Android: Upload to Google Play Console
    - [ ] Android: Submit for review
    - [ ] Monitor review status
    - [ ] Respond to reviewer questions

12. Post-launch:
    - [ ] Monitor crash reports
    - [ ] Monitor user reviews
    - [ ] Respond to reviews
    - [ ] Track analytics
    - [ ] Fix critical bugs ASAP
    - [ ] Plan next update

CONGRATULATIONS! Your mobile app is ready for launch! ðŸŽ‰

Remember to:
- Keep the backend API running
- Monitor server performance
- Update app regularly
- Listen to user feedback
- Fix bugs promptly
- Add new features based on demand
```

---

## ðŸŽ¯ USAGE INSTRUCTIONS

**Copy each prompt above (PROMPT 1 through PROMPT 30) and give them to Claude Code ONE AT A TIME.**

**Wait for each prompt to be fully completed before moving to the next one.**

**This ensures proper implementation and prevents overwhelming Claude Code.**

---

## ðŸ“± EXPECTED TIMELINE

- **Prompts 1-10**: Foundation & Core UI (Week 1-2)
- **Prompts 11-20**: Features & Functionality (Week 3-4)
- **Prompts 21-25**: Advanced Features (Week 5-6)
- **Prompts 26-30**: Polish & Launch (Week 7-8)

**Total estimated time: 8-10 weeks for complete mobile app**

---

## ðŸš€ AFTER COMPLETION

You'll have a fully functional, professional mobile app that:
- âœ… Matches your web app's design
- âœ… Connects to your existing backend
- âœ… Supports NFC scanning
- âœ… Works offline
- âœ… Has biometric auth
- âœ… Includes push notifications
- âœ… Ready for App Store & Google Play

**Good luck with your mobile app development!** ðŸŽ‰
